\documentclass{article}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}

%Metadata
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

%Headers and Footers
\pagestyle{fancy}
\fancyhf{}
\lhead{The Maze Game}
\rhead{Harshil Solanki}
\fancyfoot[C]{\thepage}

% preamble
\begin{document}
\title{
The\\
Maze\\
Game\\
}
\author{Harshil Solanki}
\date{}
\maketitle
\tableofcontents
\clearpage


\section{Lorem}
See~\cite{thebook}

%%%%%%ALGORITHMS STUDIED%%%%%%
\section{Maze Generation Algorithms}
\subsection{Krsukal's Algorithm}
[\href{https://weblog.jamisbuck.org/2011/1/3/maze-generation-kruskal-s-algorithm}{Source}]\\
Kruskal's algorithm is a method for producing a minimal spanning tree from a weighted graph. It works something like this:

\begin{enumerate}
    \item Throw all of the edges in the graph into a big burlap sack. (Or, you know, a set or something.)
    \item Pull out the edge with the lowest weight. If the edge connects two disjoint trees, join the trees. Otherwise, throw that edge away.
    \item Repeat until there are no more edges left.
\end{enumerate}

The {\it Randomized Kruskal's algorithm} just changes the second step, so that instead of pulling out the edge with the lowest weight, you remove an edge from the bag at random. Making that change, the algorithm now produces a fairly convincing maze.

\subsection{Prism's Algorithm}
%https://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm
The standard version of the algorithm works something like this:
\begin{enumerate}
    \item Choose an arbitrary vertex from G (the graph), and add it to some (initially empty) set V.
    \item Choose the edge with the smallest weight from G, that connects a vertex in V with another vertex not in V.
    \item Add that edge to the minimal spanning tree, and the edge's other vertex to V.
    \item Repeat steps 2 and 3 until V includes every vertex in G.
\end{enumerate}

And the result is a minimal spanning tree of G. For maze generation, in the second step, we select a random edge instead of edge with lowest weight.

\subsection{Recursive Backtracing}
%https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking
Here's the mile-high view of recursive backtracking:
\begin{enumerate}
    \item Choose a starting point in the field.
    \item Randomly choose a wall at that point and carve a passage through to the adjacent cell, but only if the adjacent cell has not been visited yet. This becomes the new current cell.
    \item If all adjacent cells have been visited, back up to the last cell that has uncarved walls and repeat.
    \item The algorithm ends when the process has backed all the way up to the starting point.
\end{enumerate}

Seems simple enough.

\subsection{Aldous-Broder Algorithm}
%https://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm
Aldous and Broder were researching these uniform spanning trees, and independently arrived at the following algorithm:
\begin{enumerate}
    \item Choose a vertex. Any vertex.
    \item Choose a connected neighbor of the vertex and travel to it. If the neighbor has not yet been visited, add the traveled edge to the spanning tree.
    \item Repeat step 2 until all vertexes have been visited.
\end{enumerate}

Note: this algorithm is notable in that it selects from all possible spanning trees (i.e. mazes) of a given graph (i.e. field) with equal probability. The other algorithms shown don't have this property.

\subsection{Wilson's Algorithm}
%https://weblog.jamisbuck.org/2011/1/20/maze-generation-wilson-s-algorithm
Note: a spanning tree is a tree that connects all the vertices of a graph. A uniform spanning tree (UST) is any one of the possible spanning trees of a graph, selected randomly and with equal probability.
The algorithm goes something like this:
\begin{enumerate}
    \item Choose any vertex at random and add it to the UST.
    \item Select any vertex that is not already in the UST and perform a random walk until you encounter a vertex that is in the UST.
    \item Add the vertices and edges touched in the random walk to the UST.
    \item Repeat 2 and 3 until all vertices have been added to the UST.
\end{enumerate}

So, it's still doing the random walk, but this algorithm converges much more rapidly than Aldous-Broder.
\subsection{Hunt and Kill Algorithm}
%https://weblog.jamisbuck.org/2011/1/24/maze-generation-hunt-and-kill-algorithm
Toda's algorithm is the “hunt-and-kill algorithm”. Sounds violent, doesn't it? It's actually quite tame. In a nutshell, it works like this:

\begin{enumerate}
    \item Choose a starting location.
    \item Perform a random walk, carving passages to unvisited neighbors, until the current cell has no unvisited neighbors.
    \item Enter “hunt” mode, where you scan the grid looking for an unvisited cell that is adjacent to a visited cell. If found, carve a passage between the two and let the formerly unvisited cell be the new starting location.
    \item Repeat steps 2 and 3 until the hunt mode scans the entire grid and finds no unvisited cells.
\end{enumerate}

\subsection{Growing Tree Algorithm}
%https://weblog.jamisbuck.org/2011/1/27/maze-generation-growing-tree-algorithm
A slick algorithm. Here's how it works:

\begin{enumerate}
    \item Let C be a list of cells, initially empty. Add one cell to C, at random.
    \item Choose a cell from C, and carve a passage to any unvisited neighbor of that cell, adding that neighbor to C as well. If there are no unvisited neighbors, remove the cell from C.
    \item Repeat step 2 until C is empty.
\end{enumerate}

Pretty straight-forward, really. But the fun lies in how you choose the cells from C, in step 2. If you always choose the newest cell (the one most recently added), you'll get the recursive backtracker. If you always choose a cell at random, you get Prim's. It's remarkably fun to experiment with other ways to choose cells from C.

\subsection{Eller's Algorithm}
%https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm
It does this by building the maze one row at a time, using sets to keep track of which columns are ultimately connected. But it never needs to look at more than a single row, and when it finishes, it always produces a perfect maze.

Like the recursive backtracking algorithm, here's the “mile-high” overview of Eller's algorithm:
\begin{enumerate}
    \item Initialize the cells of the first row to each exist in their own set.
    \item Now, randomly join adjacent cells, but only if they are not in the same set. When joining adjacent cells, merge the cells of both sets into a single set, indicating that all cells in both sets are now connected (there is a path that connects any two cells in the set).
    \item For each set, randomly create vertical connections downward to the next row. Each remaining set must have at least one vertical connection. The cells in the next row thus connected must share the set of the cell above them.
    \item Flesh out the next row by putting any remaining cells into their own sets.
    \item Repeat until the last row is reached.
    \item For the last row, join all adjacent cells that do not share a set, and omit the vertical connections, and you're done!
\end{enumerate}

\section*{My Algorithm}
Taking inspiration from the previous algorithms, I'm going to implement my algorithm in this way:

\begin{enumerate}
    \item Make a random path from start-point to the end-point.
    \item Choose two arbitrary points in this path and block the initial path we made between them and generate another random path.
    \item Repeat the previous step according to the complexity of maze.
    \item Use Hunt and Kill algorithm to verify no cell is univisited.
\end{enumerate}

\printbibliography

\end{document}